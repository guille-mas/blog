---
slug: "build-a-php-dev-environment-your-team-will-love/index.html"
title: "Build a PHP development environment your team will love"
intro: "Learn to create a full fledged, containerized, development environment for your PHP projects. Learn to update it, destroy it, recreate it, or share it with others; With confidence and in a breeze!"
tools: "php xdebug docker docker-compose gnu-make"
date: "02-10-2020"
publish: true
blog: true
category: tutorial
---
import { CodeWave } from "gatsby-theme-waves"
import Code from "components/code"
import "prismjs/components/prism-docker"

Welcome to my first tutorial ( yikes! )

<br />

Hopefully it will help you achieve a meaningful task that will save your team countless hours of tedious tasks. Like setting up the right language interpreter, the right libraries, configuration files, vendor versions, or debugging issues caused by inconcistencies between environments.  

<br/>

If you follow through you should end up with a working, Linux based, PHP 7.4, portable development environment, with a working XDebug PHP debugger, that can be deployed with a single command, on virtually any computer that fulfills the needed requirements.  

<br />

The environment will allow you to:

- Reduce time dedicated to setting up future development environments
- Ease bug reproduction between environments
- Communicate in code every relevant aspect of your environment to others
- Reorganize your project folders structure, dependencies, infrastructure, or try other ideas; Sharing those changes faster than ever
- Help your dev team be more aware of the context on which their project is running
- Communicate with clear, concise code, the details of your project runtime to an IT team
- Create the first building stone of any modern automated infrastructure

### Hold on... Isn't it pure hype, or rocket science for big companies like Google or Facebook?

Not exactly. In fact it's great for small startups that know what they are doing with it. And the use case we are going to explore on this guide doesn't require a big learning curve. Stick with me and you will see ;)

### Ok, what's Docker then?

Docker is a software that allows you to pack your applications around their own environment; With the OS and files you want them to be executed. And it also can wire them up together to define architectures of interconnected packages, and orchestrate them all together. 

<br/>

It's a great tool that makes it possible for developers and sysadmins to run Linux or Windows applications, on virtually any environment; A cloud infrastructure provider like Amazon, a dedicated server, a virtual machine, a personal computer, a Rasberry PI, Linux, Unix, Windows, MacOS, IoT, a single instance or even a cluster...  

<br/>

Any computer capable of running a Docker engine can run your application in a reproducible way, regardless of the operating system where Docker is running from. And every time you throw a package in the wild you can expect to behave exactly as in the environment where you have created it.  

<br/>

Isn't it great? Long gone are the days where everyone in your team had to create their own development environments, sometimes with different php versions or libraries. Waisting hours in the best cases, trying to make them as similar as possible to the staging version. Only to find out, months later, after a failed deployment, that the production environment was changed overnight, leaving undocummented inconsistencies between them.

<br/>

But how Docker does that? Well, each containerized app is loaded on top of a minimum Linux or Windows abstraction layer; with their own file system, eventually plugged into one or more virtual networks; limited by a certain amount of CPU and memory available for them.

<br/>

You might be asking now, what is the difference with virtual machines (VMs)?  
The main difference is that Docker does not handle hardware virtualization, making their isolated packages much lighter, with much reduced resources footprint. Making it so easy to create a new instance of the exact same environment, that it has become easier sometimes to create new ones and destroy the old ones once the process gets accomplished; greatly simplifying infrastructure management. Even allowing sysadmins to sleep by night knowing that their infrastructure can self heal if something bad happens.  

<br/>

A docker image its like a blueprint for docker container. It is defined in a file usually named Dockerfile.  
To use an analogy taken from OOP; A docker image its like a class, and a docker container its like an instance of a docker image.  
You can create as many containers as you want from a single image.  

<br/>

You can use others people images, by pulling them from publicly available repositories, such as [DockerHub](https://hub.docker.com). Or you can upload your custom images to a private repo to use inside your organization.  
It is a recommended practice to use official docker images from certified docker repositories whenever possible.  

<br/>

For this tutorial we are going to use an [official PHP image](https://hub.docker.com/_/php) based on a debian distro; Bundled alltogether with an Apache server.  

<br/>

For production environments you should define one image per process. That way you can administer hardware resources with more granularity, besides having an easier time debugging issues related with your containers.  

> **Best practice:** Pack one service per image to increase stability, resources administration, and ease logging

### Requirements

Before creating our first container, we will need **Docker engine**, **docker-compose**, and **GNU Make**.  

<br/>

The easiest way to setup Docker and docker-compose in Windows and MacOS is by getting [Docker Desktop](https://www.docker.com/products/docker-desktop).  
If you are using Linux you can use your package manager of choice, or compile both from source.

<br/>

GNU Make might be already available in Windows through PowerShell, and its usually present on most popular Linux distros as well as MacOS.

<br/>

Finally, create a folder for this tutorial and add share it with Docker. In MacOSs Docker Desktop it goes like this:  

<br/>

> Preferences -> Resources -> File Sharing

<br/>

Sharing your folder with Docker its a prerequisite to copy whatever file you will need to run inside your docker containers.  

#### Hello World! / Hello Container!

Enough theory, lets get our hands dirty!  

<br/>

First, create an index.php file inside your project folder, with the following content

<Code language="php" snippet={`<?php phpinfo(); `} />  

<br/>

Run this command in a terminal

<br/>

<Code language="bash" snippet={`docker run -p 80:80 -v "$PWD":/var/www/html php:7.4.2-apache`} />  

If everything went weel, you should see a page with information about your PHP environment at http://0.0.0.0

##### What happened?

1. First, Docker will try to find a local image **php:7.4.2-apache**  
Since the first time the image wont be available locally, docker will proceed to download it from its remote location.  
Next time you try to create a new container based on the same image, Docker will find the local image and wont attempt to download it.
2. Docker will create a new container based on that image; Mapping port 80 on your computer with port 80 in your container, and mounting the folder specified in **"$PWD"** as folder **/var/www/html** inside your container.
3. Finally, you will see PHP and Apache logs being streamed to your terminal.

<br/>

**Note** Use an absolute path if $PWD points to a symlinked folder.

### Custom Docker images

So far you where able to start an existing docker image with **docker run**, and that's cool for projects whose only requirements are those provided by an existing image. But for most real life projects we need to bake our own images to fulfill existing requirements.  
Docker allows us to extend existing images, and add on top of them, the requirements we need for our specific project.  

<br/>

We are going to code our own custom docker image soon. But first, let's see a few userful Dockerfile instructions.

#### Basic Dockerfile usage

<CodeWave>

```docker
# This is a comment
```

##### Comments

You can write comments in your Dockerfiles  

<br/>

Each line must be preceeded by **#**

<br/>

Multi-line comments are not allowed

```docker
# This is a comment
FROM base-image-name
```

##### FROM

Define what existing image to use as the foundation for your custom image.  

<br/>

Every valid Dockerfile must begin with this instruction, except by comments and a few other exceptions.  

<br/>

Images can be public like those in Dockerhub public repos, or private, like those built by your company.

```docker
# This is a comment
FROM base-image-name:default
```

###### TAG

You can - and should - define a specific tag for the images you consume from others.  

<br/>

If you don't do it, Docker will do it for you!  

<br/>

That's bad cause **"default"** points to the latest build of a specific flavor of those images.  

<br/>

Not choosing a tag for your images makes your build process unreliable in the long run.

```docker
# This is a comment
FROM base-image-name:1.2-variant
```

> **Best Practice:** Always use an explicit tag; a specific version of the images you consume in order to avoid upstream breaking changes in the future

> "Not choosing a tag for your images makes your build process unreliable in the long run"

```docker
# This is a comment
FROM base-image-name:1.2-variant
RUN echo "hello world"
```

**RUN** allows you to run shell commands inside your image.  

<br/>

Each time you use RUN, docker will create a new isolated file system layer.  

<br/>

Each file system layer will be merged later inside each new container you create from your images.

```docker
# This is a comment
FROM base-image-name:1.2-variant
RUN echo "hello world"
RUN do-something
RUN do-something-else
```

You can use **RUN** as many times as you want, but bear in mind that every time you use it, it will significantly increase the size of your image by adding a new file system layer.  

```docker
# This is a comment
FROM base-image-name:1.2-variant
RUN echo "hello world" \
    && do-something \
    && do-something-else
```

Luckily, you can chain shell commands together in order to reduce the amount of **RUN** lines.  

<br/>

> **Best Practice:** Chain shell commands together when possible to reduce image size

```docker
# This is a comment
FROM base-image-name:1.2-variant
RUN echo "hello world" \
    && do-something \
    && do-something-else
ENV YOUR_NAME message
RUN echo "hello $YOUR_NAME"
```

**ENV** defines environment variables

```docker
# This is a comment
FROM base-image-name:1.2-variant
RUN echo "hello world" \
    && do-something \
    && do-something-else
ENV YOUR_NAME message
RUN echo "hello $YOUR_NAME"
COPY ./public /var/www/html
```

Use **COPY** to put files from between your docker context inside your image

```docker
# This is a comment
FROM base-image-name:1.2-variant
RUN echo "hello world" \
    && do-something \
    && do-something-else
ENV YOUR_NAME message
RUN echo "hello $YOUR_NAME"
COPY ./public /var/www/html
EXPOSE 8080/tcp
```

Alternatively you can **EXPOSE** ports in your image

</CodeWave>

#### Writing a custom PHP image with debugging capabilities

Let's bake a custom version of the image we tried previously, except by an interesting few additions: Xdebug, and an XDebug powered PHP remote debugger listening on port 9000.


##### Create a Dockerfile

First, create a new file in the root of your project and name it `Dockerfile`. That's the default filename Docker will look for when building your image.  


<CodeWave>

```docker title="PHP Image Dockerfile"
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
```

##### Choose a base image

The first instruction it's **FROM**.  
It tells Docker, which image to use as a base for your custom image, and how to name your custom image.  
The image you choose must exist and you need to have access to it.  

<br/>

For this tutorial we are going to use the same official PHP image we used as a base to run the apache container from the previous section, which is public for any Dockerhub's user. If you ever want to check it's source code, you can find it here: [Dockerfile available here](https://github.com/docker-library/php/blob/master/7.4/buster/apache/Dockerfile).  

<br/>

Finally, we are referencing our custom image, in the context of our build process, as `dev-image`  

```docker title="PHP Image Dockerfile"
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
RUN pecl install xdebug-2.8.1 \
    && docker-php-ext-enable xdebug
```

##### Xdebug

Use _pecl_ to install xdebug php extension, and _docker-php-ext-enable_ to enable it.  

<br/>


```docker title="PHP Image Dockerfile"
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
RUN pecl install xdebug-2.8.1 \
    && docker-php-ext-enable xdebug
# @todo Copy xdebug config into the container 
EXPOSE 9000
```

##### PHP debugger setup

Expose port 9000 and copy the xdebug configuration settings required to enable the PHP remote debugging server at port 9000.


And that's it!

</CodeWave>

#### Building your image

Get back to your shell and run:

<Code 
    language="bash" 
    snippet={`docker build -t my-project:1.0-development --target dev-image .`} 
    output={`
Sending build context to Docker daemon  3.072kB
Step 1/2 : FROM php:7.4.2-apache AS dev-image
...
Step 2/2 : RUN pecl install xdebug-2.8.1     && docker-php-ext-enable xdebug
...
 ---> 105de83fa100
Successfully built 105de83fa100
Successfully tagged my-project:1.0-development
`} />

If everything went well, you should see **my-project** custom image as follows:

<Code 
    language="bash" 
    snippet={`docker image ls`}
    output={`
REPOSITORY                TAG                 IMAGE ID            CREATED             SIZE
my-project                1.0-development     105de83fa100        31 minutes ago      416MB
php                       7.4.2-apache        4165e46dd82e        2 weeks ago         414MB
`} />

### Wire your infra with docker-compose

### Upload your images

### Whats next
