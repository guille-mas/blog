---
slug: "build-a-php-dev-environment-your-team-will-love/index.html"
title: "Build a PHP 7 development environment your team will love"
intro: "Learn to build a portable PHP development environment with Docker"
tools: "docker gnu-make php xdebug debian-linux"
date: "02-24-2020"
publish: true
blog: true
category: tutorial
---
import { CodeWave } from "gatsby-theme-waves"
import Code from "components/code"
import ContactLink from "components/contact-link"
import "prismjs/components/prism-docker"

> Welcome! This post it's a work in progress and will be changing during the next few days. 
> Don't hesitate to write me an email to <ContactLink/> with any comments, critics or advices you might have.

### Intro

When we build tools we must think in our users. The time they need to become proficient with them, depends on the ideas that drive our design.  
I think internal tools and processes shouldn't be an exception to this; Empathy it's key to increase the business outcomes produced with them.  

<br />

In this post you will use Docker to wrap a PHP project into a full fledged, portable development environment, with several tools to debug software issues effectively.  

### Requirements

You need **Docker engine** ( mine is 19.03 ), and **GNU Make**.

<br/>

The easiest way to setup Docker in Windows and MacOS is by getting [Docker Desktop](https://www.docker.com/products/docker-desktop).  
GNU Make might be already available in Windows through PowerShell, and its usually present on most popular Linux distros as well as MacOS.  
Linux users can get both via their default package manager. Two popular package managers for other environments are brew (MacOS), and chocolatey (Windows).

<br/>

Next, create a DockerHub account, and sign in from the command line.

<Code language="terminal" snippet={`docker login`} />  

### Basic Docker concepts

Docker allows you to pack your applications around a runtime environment of your choice, provision your environment once, and deploy it anywhere with a docker engine. 
Containers are lighter than virtual machines and share the kernel of their host; Usually run a single process, packed with a minimum operating system, files and environment variables.  
Instead of long lasting dedicated servers, containerized infrastructure can be ephemeral and disposable. 

##### Images

A Docker image it's the blueprint from where containers are created.  
For those comming from software development and object oriented programming, an image can be seen as a class and a container as an instance. 
An image it's just a stopped container.  
Custom images are extended from existing images, and can be shared with others by pushing them to docker repositories.

<br/>

Each Docker image is composed of several layers, and each layer encapsulates an isolated portion of a file system.  
Every layer is identified with a unique hash ID. The layer at the top of the stack gives the image it's hash ID. 
You can create a new container from a specific layer by its ID. The resulting file system will be the sum of every stacked layer created before.  

##### Windows Images vs Linux images

Docker can run two types of images: Linux or Windows images.  
The difference is the kernel they need to interact with in order to access hardware resources.  
It is possible to run Windows images on a computer running Linux, and visceversa, by running a docker engine on top of a virtual machine.
Both Windows and MacOS docker versions run Linux images by default, on top of a lightweight VM. However Docker for Windows can spin up Windows images, by running natively.  
In MacOS a Windows VM as a docker host to spin up Windows images.

##### Docker Volumes

At runtime, you can mount folders of your Docker host as volumes inside a container. The command to do that is **docker run** with the **-v** flag.

##### Inmutable vs mutable images

Inmutable images already contain every file needed to run it's process. A mutable image instead it's an image that gets updated at runtime.  
Inmutable images allows you to implement simpler deployment processes, at the expense of longer build times.

##### Docker networking

Docker relies on the Container Network Model (CNM), a pluggable open-source architecture, to provide networking capabilities. 
CNM is extended to provide different network topologies. 
Docker supports the following implementations out of the box:

- Linux network drivers
    - bridge
    - overlay
    - macvlan
- Windows network drivers
    - nat
    - overlay
    - transparent
    - l2bridge

Many other implementations exist maintained by third parties.  

<br/>

Bridge are single host networks, and the default option when running docker containers. Their Windows counter part is NAT.

<br/>

<hr/>

### Run a container from an inmutable image

The environments used to implement and deploy this website are docker containers based on a specific version of the official nodejs image.  
If you are curious about it, you can read the [Dockerfile code for this website](https://github.com/guille-mas/blog/blob/master/Dockerfile).  
You can run the same version that's available at https://guille.cloud, locally, without caring or knowing what's under the hoods. 
And do so any time you want, expecting the same results to happen each time.

<br/>

Go ahead and try it

<Code language="bash" snippet={`docker run -p 8000:8000 --rm guillermomaschwitz/blog:1-production`} />  

An exact version of this website should be available at http://0.0.0.0:8000 or http://localhost:8000. Your container has the same content you are reading in this tab.

<br/>

Unless my Dockerfile it's buggy, it should work out of the box, cause Docker did all the heavy lifting for you:

1. Docker attempts to find the image **guillermomaschwitz/blog:1-production** locally. If it locally fails, attempts to pull it from its Dockerhub repository.
2. Start a new container, with a random name, based on **guillermomaschwitz/blog:1-production**.
4. Docker binds localhost's port 8000 with the container exposed port 8000 by running it with **-p 8000:8000**. 
5. Web server logs are streamed to the screen.
6. The running container is destroyed once stopped, because of the flag **--rm**.

#### List every container running at your Docker host

**docker container ls** lists every running container. The output should look as follows:

<Code 
language="bash" 
snippet={`docker container ls`} 
output={`
CONTAINER ID        IMAGE                                  COMMAND                  CREATED             STATUS              PORTS                    NAMES
7ecd413bdf91        guillermomaschwitz/blog:1-production   "docker-entrypoint.sâ€¦"   23 minutes ago      Up 23 minutes       0.0.0.0:8000->8000/tcp   peaceful_almeida
`}/>  

If everything went well, you should see a similar list in your terminal; A running container with a unique ID and NAME.

To list stopped containers as well, use the **-a** flag.  

#### A few useful Docker commands

##### List every local image

<Code language="bash" snippet={`docker image ls`} />  

##### Execute a command inside a running container

<Code language="bash" snippet={`docker exec <container-name-or-id> <command>`} />  

Use the **-it** flag to execute the command in "interactive" mode, streaming it's output to your screen.

<br/>

Run bash or other available shell in interactive mode to debug or try things inside your container.

<Code language="bash" snippet={`docker exec -it <container-name-or-id> bash`} />

##### Run a command in a new container

<Code language="bash" snippet={`docker run [--name new-container-name] <docker-image> <command>`} />

##### Stop a container

<Code language="bash" snippet={`docker stop <container-name-or-id>`} />

##### Remove a container

<Code language="bash" snippet={`docker rm <container-name-or-id>`} />

##### Remove an image

<Code language="bash" snippet={`docker image rm <docker-image>`} />

Example:

<Code language="bash" snippet={`docker image rm guillermomaschwitz/blog:1-production`} />

<br/>

<hr/>

## Create a custom image with a PHP development environment

### Share your project folder with Docker

Allow Docker to read your project's folder.  
At least in Docker Desktop for MacOS, it goes like this:  

1. Go to Docker Desktop's preferences
2. Go to File Sharing, under Resources section
3. Add your folder and apply changes

Avoid symlinked folders cause Docker will complaint.

#### Create the basic folder and files required for this project

Copy the sample project from https://github.com/guille-mas/blog/tree/master/code-samples/php-docker-development-environment

#### Sample project structure

- ./config
    - The place for server configuration files.
- ./src
    - PHP sourcode
- ./src/public
    - Public facing PHP sourcode.
- Makefile
    - High level cli interface. Important to delay learning curve to others, and ease adoption of the environment.
- README.md
    - The first place where people should look for guidance to start the environment.
    Should have the minimum amount of information. Iterate on it each time someone asks you something that was not docummented there.
- ./data
    - Folder used by PHP's tracer and profiler to output reports.
- .gitignore
    - Flag files to exclude from GIT repo.
- .dockerignore
    - Flag files to exclude from Docker builds.

#### The Dockerfile

Docker uses Dockerfiles as recipes to creat images.

<CodeWave>

```docker
# My PHP Development environment
FROM php:7.4.2-apache
```

##### Use an official base image

**FROM** its usually the first instruction you will use on your Dockerfiles.  
It tells Docker, which base image to use.  
Docker images are tagged with the following syntax:

<br/>

< **name** > **:** [ **version** ]

<br/>

The image you choose must exist and you need to have access to it.  
Use the [official PHP image, bundled with Apache](https://hub.docker.com/_/php), whose name its "php", and its version "7.4.2-apache"  
Be explicit with image versions you consume, to protect your image from upstream's breaking changes.

<br/>

Docker has a vibrant ecosystem of images you can consume. One of the most popular repositories for storing them is [DockerHub](https://hub.docker.com/), with thousands of repositories publicly available, built by devops practitioners around the world.  

> For improved security and stability, your custom images should rely on [official images](https://docs.docker.com/docker-hub/official_images/); A curated list of images maintained by strict quality standards

If you want to check it's source code, you can [read its Dockerfile from Github](https://github.com/docker-library/php/blob/master/7.4/buster/apache/Dockerfile).  

<br/>

```docker
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
```

##### Set an alias for your image

An alias labels an image in the build process. The label for **php:7.4.2-apache** is **dev-image**.  

<br/>

Many image definitions can be written on the same Dockerfile.  
An alias help you identify a specific image.

```docker
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
# Install XDebug
RUN pecl install xdebug-2.8.1
RUN docker-php-ext-enable xdebug
```

##### Run shell commands

**RUN** will run each sentence in the default shell.

<br/>

Install [XDebug](https://xdebug.org/); A development PHP extension that packs handy features to make your life easier while debugging stuff.  
As [docummented here](https://hub.docker.com/_/php), use _pecl_, and _docker-php-ext-enable_.  

<br/>

You can use RUN as many times as you want, but bear in mind that every time you use it, the size of your image will increase significantly.

<br/>

```docker
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
# Install XDebug
RUN pecl install xdebug-2.9.2 \
    && docker-php-ext-enable xdebug
```

##### Optimize the size of your image

Luckily, you can chain shell commands together in order to reduce the amount of RUN lines.

> Unless you want to cache specific steps of your build process, it is a good practice, to replace consecutive RUN lines, by a single line of chained sentences


```docker
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
# Install XDebug
RUN pecl install xdebug-2.9.2 \
    && docker-php-ext-enable xdebug \
# Create data folders for XDebug
# tracing and profiling tools
# and set ownership to www-data
    && mkdir -p /tmp/mydata \
    && chown -R www-data:www-data /tmp/mydata
# copy development settings for PHP
COPY ./config/development.ini /usr/local/etc/php/conf.d/
```

##### Configure PHP and XDebug

**COPY** allows you to copy files and folders from your host into your image.

1. Let's create with **RUN**, a folder  /tmp/mydata inside your image, to store output files generated with XDebug tracer and profiler
1. **COPY** the file config/development.ini into /usr/local/etc/php/conf.d/ inside your image, so PHP can load your settings automatically


```docker
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
# Install XDebug
RUN pecl install xdebug-2.9.2 \
    && docker-php-ext-enable xdebug \
# Create data folders for XDebug
# tracing and profiling tools
# and set ownership to www-data
    && mkdir -p /tmp/mydata \
    && chown -R www-data:www-data /tmp/mydata
# copy development settings for PHP
COPY ./config/development.ini /usr/local/etc/php/conf.d/
# copy the PHP source code inside your image
COPY --chown=www-data:www-data ./src /usr/local/project
# symling your project folder 
# with default's public apache folder
RUN ln -s /usr/local/project/public /var/www/html
```

##### Copy your project source code inside the image

1. **COPY** your local folder src/ into /usr/local/project inside your images, and assign the ownership of those files to user www-data
2. Then use **RUN** to symlink /var/www/html to /usr/local/project/public folder


```docker
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
# Install XDebug
RUN pecl install xdebug-2.9.2 \
    && docker-php-ext-enable xdebug \
# Create data folders for XDebug
# tracing and profiling tools
# and set ownership to www-data
    && mkdir -p /tmp/mydata \
    && chown -R www-data:www-data /tmp/mydata
# copy development settings for PHP
COPY ./config/development.ini /usr/local/etc/php/conf.d/
# copy the PHP source code inside your image
COPY --chown=www-data:www-data ./src /usr/local/project
# symling your project folder 
# with default's public apache folder
RUN ln -s /usr/local/project/public /var/www/html
EXPOSE 80
```

##### Expose ports

**EXPOSE** allows you to open ports in the container.

<br/>

This is just an example, cause there's no need to expose port 80, since it's been done already on the base image.  
Bear in mind that an open port at the container, at least with the network type we are using in this tutorial won't be available at your Docker host, unless you map both ports when running the container with parameter -p.

<br/>

```docker
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
# Install XDebug
RUN pecl install xdebug-2.9.2 \
    && docker-php-ext-enable xdebug \
# Create data folders for XDebug
# tracing and profiling tools
# and set ownership to www-data
    && mkdir -p /tmp/mydata \
    && chown -R www-data:www-data /tmp/mydata
# copy development settings for PHP
COPY ./config/development.ini /usr/local/etc/php/conf.d/
# copy the PHP source code inside your image
COPY --chown=www-data:www-data ./src /usr/local/project
# symling your project folder 
# with default's public apache folder
RUN ln -s /usr/local/project/public /var/www/html
EXPOSE 80
```

And that's it. You can now use this file to build your custom image.

<br/>

Check [the Dockerfile reference](https://docs.docker.com/engine/reference/builder/) for a deep dive into every option available when writing custom images.

</CodeWave>


### Basic image workflows

#### Build your image

<Code language="bash" snippet={`docker build -t my-project:1.0-development --target dev-image .`} />

Builds and tags your image as **my-project:1.0-development**.  
The last parameter is the file system context at your Docker host. Any file you want to **COPY** into the image, must be inside the given context. 
The context must be shared with Docker through Docker settings, under the "File Sharing" section.

<br/>

If everything went well, you should see **my-project** custom image between your locally available images.

<Code language="bash" snippet={`docker image ls`} />

#### Test it as a standalone container

<Code 
language="bash" 
snippet={`docker run -p 80:80/tcp --rm --name my-project-container my-project:1.0-development`} 
/>

#### Run it as a development environment

Mount your source code and data folders with the **-v** param.  
You should also use **--rm** to tell Docker to discard the container after using it.

<Code 
language="bash" 
snippet={`docker run -p 80:80/tcp -v /absolute-path-to-project/src:/usr/local/project -v /absolute-path-to-project/data:/tmp/mydata --rm --name my-project-container my-project:1.0-development`} 
/>

#### Push it to your Dockerhub repo

To share it with other developers, push the image to your Dockerhub repo.

<Code 
language="bash" 
snippet={`docker login -u your-dockerhub-username -p "your-dockerhub-password"`}
/>

<Code 
language="bash" 
snippet={`docker push your-dockerhub-username/my-project`}
/>

<br/>

<hr/>

### Whats next

In my next post, I'll show you how to use **docker-compose** to wire multiple containers together, 
the advantages of it's declarative style, and how to write one image per environment type using Docker **multi stage builds**.

<br/>

Let me know your thoughts at <ContactLink/>

