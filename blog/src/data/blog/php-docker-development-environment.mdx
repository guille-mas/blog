---
slug: "build-a-php-dev-environment-your-team-will-love/index.html"
title: "Build a PHP 7 development environment your team will love"
intro: "Learn to build a portable PHP development environment with Docker"
tools: "docker gnu-make php xdebug debian-linux"
date: "02-24-2020"
publish: true
blog: true
category: tutorial
---
import { CodeWave } from "gatsby-theme-waves"
import Code from "components/code"
import ContactLink from "components/contact-link"
import "prismjs/components/prism-docker"
import "prismjs/components/prism-ini"

> Welcome! This post it's a work in progress and will be changing during the next few days. 
> Don't hesitate to write me an email to <ContactLink/> with any comments, critics or advices you might have.

### Intro

When we build tools we must think in our users. The time they need to become proficient, depends on the ideas that drive our design.  
I think internal tools and processes shouldn't be an exception to this; Empathy it's key to increase the business outcomes produced with them.  

<br />

In this post we will use Docker to wrap a PHP project into a full fledged, portable development environment, that I hope will help you and your development team be more effective on your day to day tasks. 
The environment will have several tools to help you debug software issues effectively: a debugger, a profiler, a tracer, colorful error reporting, and an easy way to run your automated tests.  
I will try to guide you as gentle as possible, but I will assume you grasp the basics about writing web applications in PHP, and using a linux command line.

<br />

This tutorial will focus on containerizing a single PHP application. I won't show you here howto orchestrate several containers together, or howto containerize a database. 
The containerized environment we are going to build here won't be suitable for production use.
However, the resulting container will be able to access any database you would normally access from your computer, and I think it will introduce several advantages in comparison to a native development environment.

### Requirements

Before creating our first container, you will need **Docker engine** ( I am using version 19.03, yours should be at least that version ), and **GNU Make**.

<br/>

The easiest way to setup Docker in Windows and MacOS is by getting [Docker Desktop](https://www.docker.com/products/docker-desktop).  
If you are using Linux you can use your package manager of choice, or compile it from source.

<br/>

GNU Make might be already available in Windows through PowerShell, and its usually present on most popular Linux distros as well as MacOS.  
Windows has an open source package manager called chocolatey. You might want to give it a try to install GNU Make.

### Basic Docker concepts

Docker it's an amazing tool that allows you to pack your applications around a runtime environment of your choice. 
With it you can provision your environment once, and reuse it any time you need, switching the paradigm of how deployments and other business critical tasks are performed. 
Instead of long lasting dedicated servers, containerized infrastructure it's ephemeral and disposable. 

##### Containers

Containers are a way to package a running process with everything it needs to work; The minimum operating system, file system, environment variables, and firewall rules.
A container is lighter than a virtual machine, cause instead of emulating all the required hardware required to run an entire operating system with several processes running, containers share the kernel of the host machine it is running on, using the host harware resources as well, usually specialized to run a single process.

##### Images

Docker images are the blueprint from where Docker containers are created. An image it's a build time construct, and a container it's a runtime construct. Or in other words: an image is a stopped container. 
For those comming from software development and object oriented programming, an image could be seen as a class and a container as an instance.  
Images can be pushed to Docker repositories, where they can be consumed by others to create new images and containers.  

##### Windows Images vs Linux images

There are two types of images: Linux, and Windows images.  
The difference is the kernel they need to interact with, in order to access hardware resources.  
It is possible to run Windows images on a computer running Linux, and visceversa, by spinning the containers on top of a virtual machine, with the desired operating system. That's how a Linux container can be executed with Docker for Windows.  
By default Docker for Windows it's only capable of running Linux images, by installing the Docker daemon inside a lightweight Linux VM. But you can configure Docker for Windows to install the Docker daemon natively, in order to run Windows images instead.  
Docker for MacOS doesn't run a docker daemon natively either. Instead it follows the same approach than Docker for Windows; running the Docker daemon on top of a lightweight Linux VM.

##### Docker Volumes

comming soon

##### Inmutable vs mutable infrastructure

comming soon

##### Docker networking

comming soon

### Run your first container

This blog itself, can help you understand how easy it can be to share a Docker environment. You can run the same version that's available at https://guille.cloud, locally, without caring or knowing what's under the hoods. And do so any time you want, expecting the same results.

<br/>

Go ahead and try it

<Code language="bash" snippet={`docker run -p 8000:8000 --rm guillermomaschwitz/blog:1-production`} />  

An exact version of this website will be available at http://0.0.0.0:8000 or http://localhost:8000. In fact, you could keep reading this article from it, cause that container has the same content you are seeing here.

<br/>

Let's check the running container on another terminal

<Code 
language="bash" 
snippet={`docker container ls`} 
output={`
CONTAINER ID        IMAGE                                  COMMAND                  CREATED             STATUS              PORTS                    NAMES
7ecd413bdf91        guillermomaschwitz/blog:1-production   "docker-entrypoint.sâ€¦"   23 minutes ago      Up 23 minutes       0.0.0.0:8000->8000/tcp   peaceful_almeida
`}/>  

Stop the container

<Code language="bash" snippet={`docker stop peaceful_almeida`} />

In case you didn't noticed, that was a nodejs environment, with a gatsby based website, and a long list of requirements that you don't need to be aware of. It should just works out of the box, cause Docker did all the heavy lifting for you:

1. First, it attempted to find a local image **guillermomaschwitz/blog:1-production** and ended up pulling it from its remote repo.
2. Started a new container with the random name **peaceful_almeida**, running this website on a nodejs web server
4. Container's port 8000 gets binded to localhost's (0.0.0.0) port 8000
5. Web server logs are streamed to the screen
6. The container gets destroyed once you kill the app cause we used the flag --rm.

In case you want to explore how this website's development and production environments where build, you can take a look at it's source code: https://github.com/guille-mas/blog

### Custom Docker images

Real life projects have specific requirements we need to setup in order to start them; Vendor libraries, system modules, configuration files, source files, etc.
Docker allows us to extend existing images containing some of those requirements, and create a new environment blueprint on top of them.  

### Dockerize a complete PHP 7 development environment

First, create a folder for your project and share your project's folder with Docker.  
At least in Docker Desktop for MacOS, it goes like this:  

1. Go to Docker Desktop's preferences
2. Go to File Sharing, under Resources section
3. Add your folder and apply changes

#### Create the basic folder and files required for this project

Copy the sample project from https://github.com/guille-mas/blog/tree/master/code-samples/php-docker-development-environment

#### Sample project structure

- ./config
    - The place for server configuration files
- ./src
    - The place for your code
- Makefile
    - This will be your high level environment cli interface.
    You should write here a simple set of commands to help people use the environment without having any knowledge on how Docker works.
- README.md
    - A very important file, the place where people will look for the first time they use this environment.
    It should have the minimum amount of information to help them get started without your guidance. 
    Iterate on it each time someone asks you something that was not docummented there.
- ./data
    - This folder will contain files created by PHP tracer and profiler if the developer needs them
    - This folder won't be commited to the repo, and will be automatically generated by docker
- .gitignore
    - add those files you don't want to be commited to the code; secrets, development files, garbage, etc
- .dockerignore
    - You can add the files you wan't docker to include in your image in this file. Check the docs for more information.


#### Write your image

Image builds can be automated by writing instructions on a Dockerfile.  
We are going to explore the basics of a Dockerfile syntax and instructions available while we write one.  

<CodeWave>

```docker
# My PHP Development environment
FROM php:7.4.2-apache
```

##### Use an official base image

**FROM** its usually the first instruction you will use on your Dockerfiles.  
It tells Docker, which base image to use.  
Docker images are tagged with the following syntax:

<br/>

< **name** > **:** [ **version** ]

<br/>

The image you choose must exist and you need to have access to it.  
For this tutorial we are going to use an [official PHP image, bundled with Apache](https://hub.docker.com/_/php), whose name its "php", and its version "7.4.2-apache"  
You should always be explicity with versions when using images. That way you will future proof your own image by protecting it from breaking changes.

<br/>

Docker has a vibrant ecosystem of images you can consume. One of the most popular repositories for storing them is [DockerHub](https://hub.docker.com/), with thousands of repositories publicly available, built by devops practitioners around the world.  

> For improved security and stability, your custom images should rely on [official images](https://docs.docker.com/docker-hub/official_images/); A curated list of images maintained by strict quality standards

If you want to check it's source code, you can [read its Dockerfile from Github](https://github.com/docker-library/php/blob/master/7.4/buster/apache/Dockerfile).  

<br/>

```docker
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
```

##### Set an alias for your image

Lets reference our custom image, in the context of our build process, as **dev-image**.  

<br/>

That will help you recognize your image if you add more images in the future ( a production or testing image, an image to compile assets, another to build automated docummentation, deployment pipeline specific images, etc ).  

```docker
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
# Install XDebug
RUN pecl install xdebug-2.8.1
RUN docker-php-ext-enable xdebug
```

##### Run shell commands inside your image

**RUN** will execute the sentence you pass to it in the default shell available at your image.

<br/>

We are going to use it to install [XDebug](https://xdebug.org/); A development PHP extension that packs handy features to make your life easier while debugging stuff.  
As [docummented here](https://hub.docker.com/_/php), we should use _pecl_ to install the extension and _docker-php-ext-enable_ to enable it.  

<br/>

From XDebug we are going to use the following features in this project:

- HTML/CSS formatted error messages on http responses.
- A php debugging server to debug php code at runtime.
- A tracer that once triggered with an HTTTP request will store in a human readable file, useful details about your program's flow since your request is handled by the server, till a response is sent your way.
- A profiler, that once triggered with an HTTP request, will allow you to analyze memory and cpu usage at every step of your program's flow.

You can use RUN as many times as you want, but bear in mind that every time you use it, the size of your image will increase significantly.

<br/>

```docker
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
# Install XDebug
RUN pecl install xdebug-2.9.2 \
    && docker-php-ext-enable xdebug \
```

##### Optimize the size of your image

Luckily, you can chain shell commands together in order to reduce the amount of RUN lines.

> Unless you want to cache specific steps of your build process, it is a good practice, to replace consecutive RUN lines, by a single line of chained sentences


```docker
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
# Install XDebug
RUN pecl install xdebug-2.9.2 \
    && docker-php-ext-enable xdebug \
# Create data folders for XDebug
# tracing and profiling tools
# and set ownership to www-data
    && mkdir -p /tmp/mydata \
    && chown -R www-data:www-data /tmp/mydata
# copy PHP development settings
COPY ./config/development.ini /usr/local/etc/php/conf.d/
```

##### Configure PHP and XDebug

**COPY** allows you to copy files and folders from your host into your image.

1. Let's create with **RUN**, a folder  /tmp/mydata inside your image, to store output files generated with XDebug tracer and profiler
1. **COPY** the file config/development.ini into /usr/local/etc/php/conf.d/ inside your image, so PHP can load your settings automatically


```docker
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
# Install XDebug
RUN pecl install xdebug-2.9.2 \
    && docker-php-ext-enable xdebug \
# Create data folders for XDebug
# tracing and profiling tools
# and set ownership to www-data
    && mkdir -p /tmp/mydata \
    && chown -R www-data:www-data /tmp/mydata
# copy PHP development settings
COPY ./config/development.ini /usr/local/etc/php/conf.d/
RUN ln -s /usr/local/project/public /var/www/html
```

##### Copy your project source code inside the image

1. **COPY** your local folder src/ into /usr/local/project inside your images, and assign the ownership of those files to user www-data
2. And use **RUN** to symlink /var/www/html to /usr/local/project/public folder


```docker
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
# Install XDebug
RUN pecl install xdebug-2.9.2 \
    && docker-php-ext-enable xdebug \
# Create data folders for XDebug
# tracing and profiling tools
# and set ownership to www-data
    && mkdir -p /tmp/mydata \
    && chown -R www-data:www-data /tmp/mydata
# copy PHP development settings
COPY ./config/development.ini /usr/local/etc/php/conf.d/
RUN ln -s /usr/local/project/public /var/www/html
EXPOSE 443
```

##### Expose HTTPS port

**EXPOSE** allows you to open ports in the container.

<br/>

There is no need to expose port 80, cause that has been done already on the base image. 
However we do need to open port 443 if we want to run our app over HTTPS.  
Bear in mind that an open port at the container, at least with the network type we are using in this tutorial won't be available at your docker host, unless you map both ports when running the container with parameter -p.

<br/>

```docker
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
# Install XDebug
RUN pecl install xdebug-2.9.2 \
    && docker-php-ext-enable xdebug \
# Create data folders for XDebug
# tracing and profiling tools
# and set ownership to www-data
    && mkdir -p /tmp/mydata \
    && chown -R www-data:www-data /tmp/mydata
# copy PHP development settings
COPY ./config/development.ini /usr/local/etc/php/conf.d/
RUN ln -s /usr/local/project/public /var/www/html
EXPOSE 443
```

##### That's it

Next, I will show you how to:

1. Build your image
2. Test it locally
3. Push it to a private repo
4. Share it with your team
5. Roll updates
6. Make use of several PHP debugging tools
7. Run your automated tests

<br/>

There are more instructions than those we just wrote. I recommend you check [the Dockerfile reference](https://docs.docker.com/engine/reference/builder/).

</CodeWave>

#### Build your image

Let's get back to the command line to build it. Try the following command:

<Code language="bash" snippet={`docker build -t my-project:1.0-development --target dev-image .`} />

Docker will build a new docker image based on **dev-image** and tag it as **my-project:1.0-development**. 
The last parameter is the context folder Docker will use to build your image. Any file you want to **COPY** into the image, must be inside the given context. 
The context must be shared with Docker through Docker settings, under the "File Sharing" section.

<br/>

If everything went well, you should see **my-project** custom image between your list of locally available Docker images, and the base image, used to build it.

<Code language="bash" snippet={`docker image ls`} />

#### Test it locally

comming soon

#### Push it to a private repo

comming soon

#### Share it with your team

comming soon

#### Roll updates

comming soon

#### Make use of several PHP debugging tools

comming soon

#### Run your automated tests

comming soon

### Whats next

In the next post, I plan to show you howto use **docker-compose** to effectively documment in code our development environment.
We will explore the advantages of following a declarative approach instead of an imperative one, and we will see how docker-compose can help us do so.

<br/>

Later I would like to show you how to write one image per environment type using Docker **multi stage builds**.

<br/>

Thanks a lot for your time!

