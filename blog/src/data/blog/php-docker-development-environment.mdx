---
slug: "build-a-php-dev-environment-your-team-will-love/index.html"
title: "Build a PHP 7 development environment your team will love"
intro: "Learn to build a portable PHP development environment with Docker"
tools: "docker gnu-make php xdebug debian-linux"
date: "02-24-2020"
publish: true
blog: true
category: tutorial
---
import { CodeWave } from "gatsby-theme-waves"
import Code from "components/code"
import "prismjs/components/prism-docker"
import "prismjs/components/prism-ini"

> This post is a work in progress. Let me know your thoughts; If you found this useful or not, and any errors you might spot or questions you might have.

### Intro

When we build tools we must think in our users. The time they need to become proficient, depends on the ideas that drive our design.  
I think internal tools and processes shouldn't be an exception to this; Empathy it's key to increase the business outcomes produced with them.  

<br />

In this post we will use Docker to wrap a PHP project into a full fledged, portable, development environment, that I hope will help you and your development team be more effective on your day to day tasks. 
The environment will have several tools to help you debug software issues effectively: a debugger, a profiler, a tracer, colorful error reporting, and a folder for your phpunit tests.  
I will try to be as gentle as possible on this journey, but I will assume you grasp the basics about writing web applications in PHP, and basic Linux command line usage.

<br />

This tutorial will focus on containerizing a single PHP application. I won't show you here howto orchestrate several containers together, or howto containerize a database. And the containerized environment we are going to build here won't be suitable for production use.
However, the resulting container will be able to access any database you would normally access from your computer, and I think it will introduce several advantages in comparison to a native development environment.

### Requirements

Before creating our first container, you will need a **Docker engine** version equal or greater than 19.03, and **GNU Make**.

<br/>

The easiest way to setup Docker in Windows and MacOS is by getting [Docker Desktop](https://www.docker.com/products/docker-desktop).  
If you are using Linux you can use your package manager of choice, or compile it from source.

<br/>

GNU Make might be already available in Windows through PowerShell, and its usually present on most popular Linux distros as well as MacOS.  
Windows has an open source package manager called chocolatey. You might want to give it a try to install GNU Make.

### Basic Docker concepts

- Docker it's a tool that allows you to pack your applications around a runtime environment of your choice.
- Any computer capable of running a Docker engine will run your app inside the same runtime environment. Regardless of the operating system running your host (The computer running Docker).

##### Images and containers

A Docker image it's the blueprint from where Docker containers are created.  
Images can be pushed to Docker repositories, where they can be consumed by others to create new images and containers.  
An image it's a build time construct, and a container it's a runtime construct.  
For those familiar with OOP; A Docker image could be seen as a "class" and a container as an "instance".  

<br/>

Containers alliviate a lot of heavy lifting from error prone tasks, by packaging your apps with everything they need to work with; A minimum operating system, libraries, modules, configuration files, environment variables, and firewall rules.  

### Run your first container

This blog itself, can help you understand how easy it can be to share a Docker environment. You can run the same version that's available at https://guille.cloud, locally, without caring or knowing what's under the hoods. And do so any time you want, expecting the same results.

<br/>

Go ahead and try it

<Code 
language="bash" 
snippet={`docker run -p 8000:8000 --rm guillermomaschwitz/blog:1-production`} 
output={`
Unable to find image 'guillermomaschwitz/blog:1-production' locally
1-production: Pulling from guillermomaschwitz/blog
89d9c30c1d48: Already exists 
14a328a7d891: Already exists 
7c9d8f6918aa: Already exists 
0f41cc513c96: Already exists 
60eb08073fc4: Pull complete 
925927e5d4b3: Pull complete 
6a566d986f65: Pull complete 
Digest: sha256:97219d2c6fed07921b8f3ca551e91480471599fe4720ef11bb4cb17d1793aaec
Status: Downloaded newer image for guillermomaschwitz/blog:1-production
info gatsby serve running at: http://0.0.0.0:8000/
`}/>  

An exact version of this website will be available at http://0.0.0.0:8000 or http://localhost:8000. In fact, you could keep reading this article from it, cause that container has the same content you are seeing here.

<br/>

Let's check the running container on another terminal

<Code 
language="bash" 
snippet={`docker container ls`} 
output={`
CONTAINER ID        IMAGE                                  COMMAND                  CREATED             STATUS              PORTS                    NAMES
7ecd413bdf91        guillermomaschwitz/blog:1-production   "docker-entrypoint.sâ€¦"   23 minutes ago      Up 23 minutes       0.0.0.0:8000->8000/tcp   peaceful_almeida
`}/>  

Stop the container

<Code 
language="bash"
snippet={`docker stop peaceful_almeida`}
output={`peaceful_almeida`} />

In case you didn't noticed, that was a nodejs environment, with a gatsby based website, and a long list of requirements that you don't need to be aware of. It should just works out of the box, cause Docker did all the heavy lifting for you:

1. First, it attempted to find a local image **guillermomaschwitz/blog:1-production** and ended up pulling it from its remote repo.
2. Started a new container with the random name **peaceful_almeida**, running this website on a nodejs web server
4. Container's port 8000 gets binded to localhost's (0.0.0.0) port 8000
5. Web server logs are streamed to the screen
6. The container gets destroyed once you kill the app cause we used the flag --rm.

In case you want to explore how this website's development and production environments where build, you can take a look at it's source code: https://github.com/guille-mas/blog

### Custom Docker images

Real life projects have specific requirements we need to setup in order to start them; Vendor libraries, system modules, configuration files, source files, etc.
Docker allows us to extend existing images containing some of those requirements, and create a new environment blueprint on top of them.  

### Dockerizing a custom PHP 7 development environment

First, create a folder for your project and share your project's folder with Docker.  
At least in Docker Desktop for MacOS, it goes like this:  

1. Go to Docker Desktop's preferences
2. Go to File Sharing, under Resources section
3. Add your folder and apply changes

#### Create the basic folder and files required for this project

Copy the sample project from https://github.com/guille-mas/blog/tree/master/code-samples/php-docker-development-environment

#### Sample project structure

- ./config
    - The place for server configuration files
- ./src
    - The place for your code
- Makefile
    - This will be your high level environment cli interface.
    You should write here a simple set of commands to help people use the environment without having any knowledge on how Docker works.
- README.md
    - A very important file, the place where people will look for the first time they use this environment.
    It should have the minimum amount of information to help them get started without your guidance. 
    Iterate on it each time someone asks you something that was not docummented there.
- ./data
    - This folder will contain files created by PHP tracer and profiler if the developer needs them
    - This folder won't be commited to the repo, and will be automatically generated by docker
- .gitignore
    - add those files you don't want to be commited to the code; secrets, development files, garbage, etc
- .dockerignore
    - You can add the files you wan't docker to include in your image in this file. Check the docs for more information.


#### Writing your custom image

Image builds can be automated by writing instructions on a Dockerfile.  
We are going to explore the basics of a Dockerfile syntax and instructions available while we write one.  

<CodeWave>

```docker
# My PHP Development environment
FROM php:7.4.2-apache
```

##### Parent image

The first instruction used on most Dockerfile is **FROM**.  
It tells Docker, which base image to use.  
The image you choose must exist and you need to have access to it.  

<br/>

Docker has a vibrant ecosystem of images you can consume. One of the most popular repositories for storing them is [DockerHub](https://hub.docker.com/), with thousands of repositories publicly available, built by devops practitioners around the world.  

> For improved security and stability, your custom images should rely on [official images](https://docs.docker.com/docker-hub/official_images/); A curated list of images maintained by strict quality standards

<br/>

For this tutorial we are going to use an [official PHP image, bundled with Apache](https://hub.docker.com/_/php). If you ever want to check it's source code, you can [read it from Github](https://github.com/docker-library/php/blob/master/7.4/buster/apache/Dockerfile).  

```docker
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
```

### Set an alias for your image

Lets reference our custom image, in the context of our build process, as **dev-image**.  
That will help you recognize your image if you add more images in the future ( a production or testing image, an image to compile assets, another to build automated docummentation, deployment pipeline specific images, etc ).  

```docker
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
# Install XDebug
RUN pecl install xdebug-2.8.1
RUN docker-php-ext-enable xdebug
```

##### Running instructions inside your image

**RUN** will execute the sentence you pass to it in the default terminal.

<br/>

We are going to use it to install [XDebug](https://xdebug.org/); A development PHP extension that packs handy features to make your life easier while debugging stuff.  
As [docummented here](https://hub.docker.com/_/php), we should use _pecl_ to install the extension and _docker-php-ext-enable_ to enable it.  

<br/>

From XDebug we are going to use the following features in this project:

- HTML/CSS formatted error messages on http responses.
- A php debugging server to debug php code at runtime.
- A tracer that once triggered with an HTTTP request will store in a human readable file, useful details about your program's flow since your request is handled by the server, till a response is sent your way.
- A profiler, that once triggered with an HTTP request, will allow you to analyze memory and cpu usage at every step of your program's flow.

You can use RUN as many times as you want, but bear in mind that every time you use it, the size of your image will increase significantly.

<br/>

```docker
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
# Install XDebug
RUN pecl install xdebug-2.9.2 \
    && docker-php-ext-enable xdebug \
```

##### Optimize the size of your image by chaining RUN instructions together

Luckily, you can chain shell commands together in order to reduce the amount of RUN lines.

> Unless you want to cache specific steps of your build process, it is a good practice, to replace consecutive RUN lines, by a single line of chained sentences


```docker
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
# Install XDebug
RUN pecl install xdebug-2.9.2 \
    && docker-php-ext-enable xdebug \
# Create data folders for XDebug
# tracing and profiling tools
# and set ownership to www-data
    && mkdir -p /tmp/mydata \
    && chown -R www-data:www-data /tmp/mydata
# copy PHP development settings
COPY ./config/development.ini /usr/local/etc/php/conf.d/
```

##### Configure PHP and XDebug

1. Let's create with **RUN**, a folder  /tmp/mydata inside your image, to store output files generated with XDebug tracer and profiler
1. **COPY** the file config/development.ini into /usr/local/etc/php/conf.d/ inside your image, so PHP can load your settings automatically

</CodeWave>


And that's it!  
There are more instructions than those we just wrote. I recommend you check [the Dockerfile reference](https://docs.docker.com/engine/reference/builder/).

<br/>

Now that you have a Dockerfile, let's build the image.


#### Building your custom image

Get back to your shell and run:

<Code 
    language="bash command-line" 
    snippet={`docker build -t my-project:1.0-development --target dev-image .`} 
    output={`
Sending build context to Docker daemon  3.072kB
Step 1/2 : FROM php:7.4.2-apache AS dev-image
...
Step 2/2 : RUN pecl install xdebug-2.8.1     && docker-php-ext-enable xdebug
...
 ---> 105de83fa100
Successfully built 105de83fa100
Successfully tagged my-project:1.0-development
`} />

Docker will build a new docker image based on **dev-image** and tag it as **my-project:1.0-development**.

<br/>

If everything went well, you should see **my-project** custom image between your list of locally available Docker images, and the base image, used to build it.

<Code 
    language="bash" 
    snippet={`docker image ls`}
    output={`
REPOSITORY                TAG                 IMAGE ID            CREATED             SIZE
my-project                1.0-development     105de83fa100        31 minutes ago      416MB
php                       7.4.2-apache        4165e46dd82e        2 weeks ago         414MB
`} />

### Whats next

In the next post, I plan to show you howto use **docker-compose** to effectively documment in code our development environment.
We will explore the advantages of following a declarative approach instead of an imperative one, and we will see how docker-compose can help us do so.

<br/>

Later I would like to show you how to write one image per environment type using Docker **multi stage builds**.

<br/>

Thanks a lot for your time!

