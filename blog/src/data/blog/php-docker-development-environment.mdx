---
slug: "build-a-php-dev-environment-your-team-will-love/index.html"
title: "Build a PHP 7 development environment your team will love"
intro: "Learn to build a portable PHP development environment with Docker"
tools: "docker gnu-make php xdebug"
date: "02-10-2020"
publish: true
blog: true
category: tutorial
---
import { CodeWave } from "gatsby-theme-waves"
import Code from "components/code"
import "prismjs/components/prism-docker"

### Intro

When we build tools we must think on the consumer. The time they need to become proficient, depends on the ideas that drive our design.  
I think internal tools and processes shouldn't be an exception to this; Empathy it's key to increase the business outcomes produced with them.  

<br />

In this post I will show you a way of building a development environment driven by those principles. 
We will use Docker, to wrap a sample project into a full fledged, portable, development environment.  
I choose PHP 7.4.2 as the language this tool should support, but the principles exposed here should help you think about your development environment, regardless the language and version you choose.  

### Building a great development environment

I think a great development environment should basically unlock an organization's potential to quickly explore risky ideas on a safe environment.  
Throwing lengthy notes to someone new to the project, or expecting them to connect the dots from our system logs, force the same blockers to happen again, and again. 
Even worse; multiple solutions will emerge as a response to those blockers, generating inconsistencies that end up affecting our ability to catch bugs earlier and more importantly, to learn from our mistakes and pivot our processes at a competitive speed.  
Automating that process is not too difficult if we start early, as I will try to show you here.  

<br/>

So basically, this is what I think a great docker based, PHP development environment must provide:

- Should be easy to use
    - Have clear, concise high level docummentation for development workflows
    - Provide a simple client interface to remove the need to learn about Docker
    - Minimum setup required. No build process. The user must count with Docker, GNU Make, and a short README.md to get started
- Stable
    - Development settings must ensure stability and keep resources consumption under control
- Help us debug
    - Debugger
    - Profiler
    - Tracer
    - Logs
- Easy to roll updates
    - Once we build a new version, it should be available on a repository accesible by our team
    - Each version must be tagged with the same version than the project version it supports
    - The code for the environment should live in the same repo as the code of the app, maintaining both in sync
- Enable effective communication
    - By putting the environment code on the same repo as the project itself, devs can see how it was done, and potentially suggest changes with a pull or merge request
    - Each stable version of the app will have a correlative stable environment to work with
    - An IT team can read the code and docs we wrote to understand the requirements a production environment should have
    - Any dev working on a specific version, can expect a consistent experience when testing bugs, easing communication between devs
- Behave as close as possible to staging and production environments
    - This point exceeds the scope of the post, but I plan to write about this in a near future

### Requirements

Before creating our first container, we will need **Docker engine** version 19.03.5 and **GNU Make**.  
I will assume you grasp the basics about using Linux, PHP, and GNUMake.

<br/>

The easiest way to setup Docker in Windows and MacOS is by getting [Docker Desktop](https://www.docker.com/products/docker-desktop).  
If you are using Linux you can use your package manager of choice, or compile it from source.

<br/>

GNU Make might be already available in Windows through PowerShell, and its usually present on most popular Linux distros as well as MacOS.

### A few basic Docker concepts

- Docker it's a tool that allows you to pack your applications around a runtime environment of your choice.
- Any computer capable of running a Docker engine will run your app inside the same runtime environment. Regardless of the operating system running your host (The computer running Docker).

##### Images and containers

A Docker image it's the blueprint from where Docker containers are created.  
Images can be pushed to Docker repositories, where they can be consumed by others to create new images and containers.  
An image it's a build time construct, and a container it's a runtime construct.  
For those familiar with OOP; A Docker image could be seen as a "class" and a container as an "instance".  

<br/>

Containers alliviate a lot of heavy lifting from error prone tasks, by packaging your apps with everything they need to work with; A minimum operating system, libraries, modules, configuration files, environment variables, and firewall rules.  

### Hello Container

This blog itself, can help you understand how easy it can be to share a Docker environment. You can run the same version that's available at https://guille.cloud, locally, without caring or knowing what's under the hoods. And do so any time you want, expecting the same results.

<br/>

Go ahead and try it

<Code 
language="bash" 
snippet={`docker run -p 8000:8000 --rm guillermomaschwitz/blog:1-production`} 
output={`
Unable to find image 'guillermomaschwitz/blog:1-production' locally
1-production: Pulling from guillermomaschwitz/blog
89d9c30c1d48: Already exists 
14a328a7d891: Already exists 
7c9d8f6918aa: Already exists 
0f41cc513c96: Already exists 
60eb08073fc4: Pull complete 
925927e5d4b3: Pull complete 
6a566d986f65: Pull complete 
Digest: sha256:97219d2c6fed07921b8f3ca551e91480471599fe4720ef11bb4cb17d1793aaec
Status: Downloaded newer image for guillermomaschwitz/blog:1-production
info gatsby serve running at: http://0.0.0.0:8000/
`}/>  

An exact version of this website will be available at http://0.0.0.0:8000 or http://localhost:8000. In fact, you could keep reading this article from it, cause that container has the same content you are seeing here.

<br/>

Let's check the running container on another terminal

<Code 
language="bash" 
snippet={`docker container ls`} 
output={`
CONTAINER ID        IMAGE                                  COMMAND                  CREATED             STATUS              PORTS                    NAMES
7ecd413bdf91        guillermomaschwitz/blog:1-production   "docker-entrypoint.sâ€¦"   23 minutes ago      Up 23 minutes       0.0.0.0:8000->8000/tcp   peaceful_almeida
`}/>  

Stop the container

<Code 
language="bash"
snippet={`docker stop peaceful_almeida`}
output={`peaceful_almeida`} />

In case you didn't noticed, that was a nodejs environment, with a gatsby based website, and a long list of requirements that you don't need to be aware of. It should just works out of the box, cause Docker did all the heavy lifting for you:

1. First, it attempted to find a local image **guillermomaschwitz/blog:1-production** and ended up pulling it from its remote repo.
2. Started a new container with the random name **peaceful_almeida**
3. A nodejs web server's process it's started inside the container, streaming logs to the screen
3. Container's port 8000 gets binded to localhost's (0.0.0.0) port 8000
4. The container gets destroyed once you kill the app cause we used the flag --rm.

In case you want to explore how this website's development and production environments where build, you can take at it's source: https://github.com/guille-mas/blog

### The purpose of custom Docker images

Real life projects have specific requirements we need to setup in order to start them; Vendor libraries, system modules, configuration files, source files, etc.
Docker allows us to extend existing images containing some of those requirements, and create a new environment blueprint on top of them.  


### Using Docker to build a PHP 7 development environment

First, create a folder for your project and share your project's folder with Docker.  
At least in Docker Desktop for MacOS, it goes like this:  

1. Go to Docker Desktop's preferences
2. Go to File Sharing, under Resources section
3. Add your folder and apply changes

Second, create a new file in the root of your project and name it `Dockerfile`.  
That's the default file name Docker expects for your custom image.  

#### Building the image

Image builds can be automated by writing instructions on a Dockerfile.  
A complete reference to Dockerfile syntax can be found at [the official docs](https://docs.docker.com/engine/reference/builder/) if you want to check.  
Let's create a Dockerfile in the root of our project.

<CodeWave>

```docker
# My PHP Development environment
FROM php:7.4.2-apache
```

##### Parent image

The first instruction every Dockerfile needs to have is **FROM**.  
It tells Docker, which image to use as a base for your custom image, and how to name your custom image.  
The image you choose must exist and you need to have access to it.  

<br/>

Docker has a vibrant ecosystem of images you can consume. One of the most popular repositories for storing them is [DockerHub](https://hub.docker.com/), where you can pull public images from thousands of repositories built by devops practitioners.  

> For improved security and stability, your custom images should rely on [official images](https://docs.docker.com/docker-hub/official_images/), which are maintained by stricter quality standards.

<br/>

For this tutorial we are going to use an [official PHP image, bundled with Apache](https://hub.docker.com/_/php). If you ever want to check it's source code, you can find it here: [Dockerfile available here](https://github.com/docker-library/php/blob/master/7.4/buster/apache/Dockerfile).  

```docker
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
```

Finally, we are referencing our custom image, in the context of our build process, as `dev-image`  

```docker
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
RUN pecl install xdebug-2.8.1 \
    && docker-php-ext-enable xdebug
```

##### Install Xdebug

XDebug it's a common PHP development extension that packs handy features to make your life easier while debugging stuff.  
One of those things it's a PHP debugging server that's usually listening to port 9000 once enabled.  

<br/>

You can configure VSCode or other editor/IDE to connect to that port.  

<br/>

Every time you send an HTTP request to your website with the parameter XDEBUG_SESSION_START=session_name, Xdebug will start a debugging session from port 9000, that you can control from any [DBGP](https://xdebug.org/docs/dbgp) compliant client.

<br/>

As docummented on the docker image's website, we should use _pecl_ to install the extension, and _docker-php-ext-enable_ to enable it.  

<br/>


```docker
# My PHP Development environment
FROM php:7.4.2-apache AS dev-image
RUN pecl install xdebug-2.8.1 \
    && docker-php-ext-enable xdebug
# @todo Copy xdebug config into the container 
EXPOSE 9000
```

##### Expose XDebug debugging server port

Expose port 9000 and copy the xdebug configuration settings required to enable the PHP remote debugging server at port 9000.

</CodeWave>

And that's it!

<br/>

Now that you have a Dockerfile, let's build the image.


#### Building your image

Get back to your shell and run:

<Code 
    language="bash" 
    snippet={`docker build -t my-project:1.0-development --target dev-image .`} 
    output={`
Sending build context to Docker daemon  3.072kB
Step 1/2 : FROM php:7.4.2-apache AS dev-image
...
Step 2/2 : RUN pecl install xdebug-2.8.1     && docker-php-ext-enable xdebug
...
 ---> 105de83fa100
Successfully built 105de83fa100
Successfully tagged my-project:1.0-development
`} />

Docker will build a new docker image based on **dev-image** and tag it as **my-project:1.0-development**.

<br/>

If everything went well, you should see **my-project** custom image between your list of locally available Docker images, and the base image, used to build it.

<Code 
    language="bash" 
    snippet={`docker image ls`}
    output={`
REPOSITORY                TAG                 IMAGE ID            CREATED             SIZE
my-project                1.0-development     105de83fa100        31 minutes ago      416MB
php                       7.4.2-apache        4165e46dd82e        2 weeks ago         414MB
`} />

### Whats next

In a next post, I plan to show you howto use docker-compose to effectively documment in code our development environment.
We will explore the advantages of following a declarative approach instead of an imperative one, and we will see how docker-compose can help us do so.

<br/>

Later I would like to show you to write one image per environment type using Docker multi stage builds.

<br/>

This post is a work in progress. Let me know your thoughts; If you found this useful or not, and any errors you might spot or questions you might have.  

<br/>

Thanks a lot for your time!

